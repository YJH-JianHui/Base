## 异常处理原则

### 核心原则：**大部分情况下不需要捕获异常，但有少数特殊场景需要**

---

## 不需要捕获异常的场景（90%的情况）

### ❌ 不要捕获的情况

#### 1. **业务逻辑异常**
```
原因：业务异常应该直接抛出，让调用者（Controller/全局异常处理器）处理
例子：用户不存在、密码错误、账户被冻结等
```

#### 2. **参数校验异常**
```
原因：参数问题应该快速失败，让全局异常处理器统一返回错误信息
例子：参数为空、格式错误等
```

#### 3. **数据库操作异常**
```
原因：数据库异常（如主键冲突、外键约束）通常是系统级错误，应该抛出
例外：除非你要转换为更友好的业务异常
```

#### 4. **权限校验异常**
```
原因：权限不足应该直接抛出PermissionException
```

---

## 需要捕获异常的场景（10%的情况）

### ✅ 应该捕获的情况

#### 1. **异常转换（最常见）**
```
场景：将底层技术异常转换为业务异常
原因：
- 隐藏技术细节，不暴露给前端
- 提供更友好的错误提示
- 统一异常体系

例子：
- 数据库主键冲突 → "用户名已存在"
- Redis连接失败 → "系统繁忙"
- 第三方API异常 → "短信发送失败"
```

#### 2. **资源清理**
```
场景：需要确保资源被正确释放
原因：避免资源泄漏

例子：
- 文件流必须关闭
- 数据库连接必须释放
- 锁必须释放
```

#### 3. **降级处理**
```
场景：非核心功能失败时提供降级方案
原因：提高系统可用性

例子：
- 缓存失败 → 直接查数据库
- 推荐算法失败 → 返回默认推荐
- 第三方支付失败 → 切换备用支付渠道
```

#### 4. **事务补偿**
```
场景：分布式事务需要手动回滚或补偿
原因：保证数据一致性

例子：
- 订单创建失败 → 释放库存
- 支付失败 → 取消订单
```

#### 5. **批量操作部分失败**
```
场景：批量操作允许部分失败
原因：不影响其他数据处理

例子：
- 批量导入100条数据，10条失败，其他90条继续
- 批量发送通知，部分失败记录日志
```

#### 6. **重试机制**
```
场景：临时性错误需要重试
原因：提高成功率

例子：
- 网络抖动导致的连接失败
- 数据库死锁（可重试）
- 第三方API限流（延迟重试）
```

#### 7. **记录特殊日志**
```
场景：需要记录详细的错误上下文
原因：便于问题排查

例子：
- 支付回调异常（需要记录完整参数）
- 定时任务失败（需要记录执行时间、参数）
- 敏感操作失败（需要记录操作人、IP等）
```

---

## 决策树

```
遇到异常 → 
    ├─ 是业务异常（用户不存在、密码错误等）？
    │   └─ 否 → 直接抛出 throw new BusinessException()
    │
    ├─ 是底层技术异常（SQL异常、IO异常等）？
    │   ├─ 需要转换为友好的业务提示？
    │   │   └─ 是 → 捕获并转换 catch (SQLException e) { throw new BusinessException("操作失败") }
    │   └─ 否 → 让它自然抛出
    │
    ├─ 是第三方API异常？
    │   ├─ 需要重试？
    │   │   └─ 是 → 捕获并重试
    │   ├─ 需要降级？
    │   │   └─ 是 → 捕获并降级
    │   └─ 否 → 捕获并转换为业务异常
    │
    ├─ 需要清理资源（文件、连接、锁）？
    │   └─ 是 → try-finally 或 try-with-resources
    │
    ├─ 是批量操作且允许部分失败？
    │   └─ 是 → 捕获并记录，继续处理其他数据
    │
    └─ 其他情况？
        └─ 让异常自然抛出，由全局异常处理器处理
```

---

## 常见错误示例

### ❌ 错误做法1：吞掉异常
```
不要这样做：
catch (Exception e) {
    log.error("错误", e);
    // 什么都不做，吞掉异常
}

问题：调用者不知道操作失败了
```

### ❌ 错误做法2：捕获后返回null
```
不要这样做：
try {
    return userMapper.selectById(id);
} catch (Exception e) {
    return null;  // 返回null
}

问题：调用者无法区分"用户不存在"还是"查询出错"
```

### ❌ 错误做法3：捕获后返回空集合（不区分场景）
```
谨慎使用：
try {
    return userMapper.selectList(query);
} catch (Exception e) {
    return Collections.emptyList();  // 可能隐藏真正的错误
}

适用场景：只在非核心功能、允许降级时使用
```

### ❌ 错误做法4：捕获后只打日志
```
不要这样做：
try {
    userMapper.insert(user);
} catch (DuplicateKeyException e) {
    log.error("插入失败", e);
    // 不抛出异常，调用者以为成功了
}

正确做法：
catch (DuplicateKeyException e) {
    log.error("插入失败", e);
    throw new BusinessException(ResultCode.USERNAME_ALREADY_EXISTS);
}
```

---

## 不同层级的异常处理责任

```
Controller层：
- 不捕获异常（让GlobalExceptionHandler处理）
- 只负责接收参数、调用Service、返回结果

Service层：
- 抛出业务异常（BusinessException）
- 转换技术异常为业务异常
- 处理事务补偿
- 实现降级逻辑
- 实现重试机制

GlobalExceptionHandler：
- 捕获所有未处理的异常
- 转换为统一的Result格式
- 记录日志
- 返回友好的错误信息
```

---

## 总结

### Service层异常处理的黄金法则：

1. **默认不捕获** - 让异常自然抛出
2. **业务异常直接抛** - `throw new BusinessException()`
3. **技术异常要转换** - 转为业务异常再抛出
4. **降级、重试才捕获** - 有特殊处理逻辑才捕获
5. **捕获后必须处理** - 不要吞掉异常
6. **finally清理资源** - 或使用try-with-resources

### 记住：

- **90%的情况不需要捕获异常**
- **捕获异常必须有明确的理由**（转换、降级、重试、清理）
- **永远不要吞掉异常**（捕获后什么都不做）
- **让全局异常处理器完成最后的工作**